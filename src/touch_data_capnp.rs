// @generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
// DO NOT EDIT.
// source: touch_data.capnp

pub mod touch_data {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::traits::Owned for Owned {
        type Reader<'a> = Reader<'a>;
        type Builder<'a> = Builder<'a>;
    }
    impl ::capnp::traits::OwnedStruct for Owned {
        type Reader<'a> = Reader<'a>;
        type Builder<'a> = Builder<'a>;
    }
    impl ::capnp::traits::Pipelined for Owned {
        type Pipeline = Pipeline;
    }

    #[derive(Clone, Copy)]
    pub struct Reader<'a> {
        reader: ::capnp::private::layout::StructReader<'a>,
    }

    impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
        const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl<'a> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a> {
        fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
            Self { reader }
        }
    }

    impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
        fn get_from_pointer(
            reader: &::capnp::private::layout::PointerReader<'a>,
            default: ::core::option::Option<&'a [capnp::Word]>,
        ) -> ::capnp::Result<Self> {
            ::core::result::Result::Ok(reader.get_struct(default)?.into())
        }
    }

    impl<'a> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a> {
        fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
            self.reader
        }
    }

    impl<'a> ::capnp::traits::Imbue<'a> for Reader<'a> {
        fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
            self.reader
                .imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
        }
    }

    impl<'a> Reader<'a> {
        pub fn reborrow(&self) -> Reader<'_> {
            Self { ..*self }
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
            self.reader.total_size()
        }
        #[inline]
        pub fn get_width(self) -> i32 {
            self.reader.get_data_field::<i32>(0)
        }
        #[inline]
        pub fn get_height(self) -> i32 {
            self.reader.get_data_field::<i32>(1)
        }
        #[inline]
        pub fn get_fingers(
            self,
        ) -> ::capnp::Result<
            ::capnp::struct_list::Reader<
                'a,
                crate::touch_data_capnp::touch_data::finger_data::Owned,
            >,
        > {
            ::capnp::traits::FromPointerReader::get_from_pointer(
                &self.reader.get_pointer_field(0),
                ::core::option::Option::None,
            )
        }
        #[inline]
        pub fn has_fingers(&self) -> bool {
            !self.reader.get_pointer_field(0).is_null()
        }
    }

    pub struct Builder<'a> {
        builder: ::capnp::private::layout::StructBuilder<'a>,
    }
    impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
        const STRUCT_SIZE: ::capnp::private::layout::StructSize =
            ::capnp::private::layout::StructSize {
                data: 1,
                pointers: 1,
            };
    }
    impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
        const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl<'a> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a> {
        fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
            Self { builder }
        }
    }

    impl<'a> ::capnp::traits::ImbueMut<'a> for Builder<'a> {
        fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
            self.builder
                .imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
        }
    }

    impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
        fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
            builder
                .init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE)
                .into()
        }
        fn get_from_pointer(
            builder: ::capnp::private::layout::PointerBuilder<'a>,
            default: ::core::option::Option<&'a [capnp::Word]>,
        ) -> ::capnp::Result<Self> {
            ::core::result::Result::Ok(
                builder
                    .get_struct(
                        <Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE,
                        default,
                    )?
                    .into(),
            )
        }
    }

    impl<'a> ::capnp::traits::SetPointerBuilder for Reader<'a> {
        fn set_pointer_builder(
            mut pointer: ::capnp::private::layout::PointerBuilder<'_>,
            value: Self,
            canonicalize: bool,
        ) -> ::capnp::Result<()> {
            pointer.set_struct(&value.reader, canonicalize)
        }
    }

    impl<'a> Builder<'a> {
        pub fn into_reader(self) -> Reader<'a> {
            self.builder.into_reader().into()
        }
        pub fn reborrow(&mut self) -> Builder<'_> {
            Builder {
                builder: self.builder.reborrow(),
            }
        }
        pub fn reborrow_as_reader(&self) -> Reader<'_> {
            self.builder.as_reader().into()
        }

        pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
            self.builder.as_reader().total_size()
        }
        #[inline]
        pub fn get_width(self) -> i32 {
            self.builder.get_data_field::<i32>(0)
        }
        #[inline]
        pub fn set_width(&mut self, value: i32) {
            self.builder.set_data_field::<i32>(0, value);
        }
        #[inline]
        pub fn get_height(self) -> i32 {
            self.builder.get_data_field::<i32>(1)
        }
        #[inline]
        pub fn set_height(&mut self, value: i32) {
            self.builder.set_data_field::<i32>(1, value);
        }
        #[inline]
        pub fn get_fingers(
            self,
        ) -> ::capnp::Result<
            ::capnp::struct_list::Builder<
                'a,
                crate::touch_data_capnp::touch_data::finger_data::Owned,
            >,
        > {
            ::capnp::traits::FromPointerBuilder::get_from_pointer(
                self.builder.get_pointer_field(0),
                ::core::option::Option::None,
            )
        }
        #[inline]
        pub fn set_fingers(
            &mut self,
            value: ::capnp::struct_list::Reader<
                'a,
                crate::touch_data_capnp::touch_data::finger_data::Owned,
            >,
        ) -> ::capnp::Result<()> {
            ::capnp::traits::SetPointerBuilder::set_pointer_builder(
                self.builder.reborrow().get_pointer_field(0),
                value,
                false,
            )
        }
        #[inline]
        pub fn init_fingers(
            self,
            size: u32,
        ) -> ::capnp::struct_list::Builder<
            'a,
            crate::touch_data_capnp::touch_data::finger_data::Owned,
        > {
            ::capnp::traits::FromPointerBuilder::init_pointer(
                self.builder.get_pointer_field(0),
                size,
            )
        }
        #[inline]
        pub fn has_fingers(&self) -> bool {
            !self.builder.is_pointer_field_null(0)
        }
    }

    pub struct Pipeline {
        _typeless: ::capnp::any_pointer::Pipeline,
    }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
        fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
            Self {
                _typeless: typeless,
            }
        }
    }
    impl Pipeline {}
    mod _private {
        pub const TYPE_ID: u64 = 0xc7e9_62a2_aa1b_ecc7;
    }

    pub mod finger_data {
        #[derive(Copy, Clone)]
        pub struct Owned(());
        impl ::capnp::traits::Owned for Owned {
            type Reader<'a> = Reader<'a>;
            type Builder<'a> = Builder<'a>;
        }
        impl ::capnp::traits::OwnedStruct for Owned {
            type Reader<'a> = Reader<'a>;
            type Builder<'a> = Builder<'a>;
        }
        impl ::capnp::traits::Pipelined for Owned {
            type Pipeline = Pipeline;
        }

        #[derive(Clone, Copy)]
        pub struct Reader<'a> {
            reader: ::capnp::private::layout::StructReader<'a>,
        }

        impl<'a> ::capnp::traits::HasTypeId for Reader<'a> {
            const TYPE_ID: u64 = _private::TYPE_ID;
        }
        impl<'a> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a> {
            fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
                Self { reader }
            }
        }

        impl<'a> ::capnp::traits::FromPointerReader<'a> for Reader<'a> {
            fn get_from_pointer(
                reader: &::capnp::private::layout::PointerReader<'a>,
                default: ::core::option::Option<&'a [capnp::Word]>,
            ) -> ::capnp::Result<Self> {
                ::core::result::Result::Ok(reader.get_struct(default)?.into())
            }
        }

        impl<'a> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a> {
            fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
                self.reader
            }
        }

        impl<'a> ::capnp::traits::Imbue<'a> for Reader<'a> {
            fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
                self.reader
                    .imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
            }
        }

        impl<'a> Reader<'a> {
            pub fn reborrow(&self) -> Reader<'_> {
                Self { ..*self }
            }

            pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
                self.reader.total_size()
            }
            #[inline]
            pub fn get_id(self) -> u32 {
                self.reader.get_data_field::<u32>(0)
            }
            #[inline]
            pub fn get_is_present(self) -> bool {
                self.reader.get_bool_field(32)
            }
            #[inline]
            pub fn get_x(self) -> f32 {
                self.reader.get_data_field::<f32>(2)
            }
            #[inline]
            pub fn get_y(self) -> f32 {
                self.reader.get_data_field::<f32>(3)
            }
            #[inline]
            pub fn get_pressure(self) -> f32 {
                self.reader.get_data_field::<f32>(4)
            }
            #[inline]
            pub fn get_size(self) -> f32 {
                self.reader.get_data_field::<f32>(5)
            }
            #[inline]
            pub fn get_orientation(self) -> f32 {
                self.reader.get_data_field::<f32>(6)
            }
            #[inline]
            pub fn get_touch_major(self) -> f32 {
                self.reader.get_data_field::<f32>(7)
            }
            #[inline]
            pub fn get_touch_minor(self) -> f32 {
                self.reader.get_data_field::<f32>(8)
            }
        }

        pub struct Builder<'a> {
            builder: ::capnp::private::layout::StructBuilder<'a>,
        }
        impl<'a> ::capnp::traits::HasStructSize for Builder<'a> {
            const STRUCT_SIZE: ::capnp::private::layout::StructSize =
                ::capnp::private::layout::StructSize {
                    data: 5,
                    pointers: 0,
                };
        }
        impl<'a> ::capnp::traits::HasTypeId for Builder<'a> {
            const TYPE_ID: u64 = _private::TYPE_ID;
        }
        impl<'a> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a> {
            fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
                Self { builder }
            }
        }

        impl<'a> ::capnp::traits::ImbueMut<'a> for Builder<'a> {
            fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
                self.builder
                    .imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
            }
        }

        impl<'a> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a> {
            fn init_pointer(
                builder: ::capnp::private::layout::PointerBuilder<'a>,
                _size: u32,
            ) -> Self {
                builder
                    .init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE)
                    .into()
            }
            fn get_from_pointer(
                builder: ::capnp::private::layout::PointerBuilder<'a>,
                default: ::core::option::Option<&'a [capnp::Word]>,
            ) -> ::capnp::Result<Self> {
                ::core::result::Result::Ok(
                    builder
                        .get_struct(
                            <Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE,
                            default,
                        )?
                        .into(),
                )
            }
        }

        impl<'a> ::capnp::traits::SetPointerBuilder for Reader<'a> {
            fn set_pointer_builder(
                mut pointer: ::capnp::private::layout::PointerBuilder<'_>,
                value: Self,
                canonicalize: bool,
            ) -> ::capnp::Result<()> {
                pointer.set_struct(&value.reader, canonicalize)
            }
        }

        impl<'a> Builder<'a> {
            pub fn into_reader(self) -> Reader<'a> {
                self.builder.into_reader().into()
            }
            pub fn reborrow(&mut self) -> Builder<'_> {
                Builder {
                    builder: self.builder.reborrow(),
                }
            }
            pub fn reborrow_as_reader(&self) -> Reader<'_> {
                self.builder.as_reader().into()
            }

            pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
                self.builder.as_reader().total_size()
            }
            #[inline]
            pub fn get_id(self) -> u32 {
                self.builder.get_data_field::<u32>(0)
            }
            #[inline]
            pub fn set_id(&mut self, value: u32) {
                self.builder.set_data_field::<u32>(0, value);
            }
            #[inline]
            pub fn get_is_present(self) -> bool {
                self.builder.get_bool_field(32)
            }
            #[inline]
            pub fn set_is_present(&mut self, value: bool) {
                self.builder.set_bool_field(32, value);
            }
            #[inline]
            pub fn get_x(self) -> f32 {
                self.builder.get_data_field::<f32>(2)
            }
            #[inline]
            pub fn set_x(&mut self, value: f32) {
                self.builder.set_data_field::<f32>(2, value);
            }
            #[inline]
            pub fn get_y(self) -> f32 {
                self.builder.get_data_field::<f32>(3)
            }
            #[inline]
            pub fn set_y(&mut self, value: f32) {
                self.builder.set_data_field::<f32>(3, value);
            }
            #[inline]
            pub fn get_pressure(self) -> f32 {
                self.builder.get_data_field::<f32>(4)
            }
            #[inline]
            pub fn set_pressure(&mut self, value: f32) {
                self.builder.set_data_field::<f32>(4, value);
            }
            #[inline]
            pub fn get_size(self) -> f32 {
                self.builder.get_data_field::<f32>(5)
            }
            #[inline]
            pub fn set_size(&mut self, value: f32) {
                self.builder.set_data_field::<f32>(5, value);
            }
            #[inline]
            pub fn get_orientation(self) -> f32 {
                self.builder.get_data_field::<f32>(6)
            }
            #[inline]
            pub fn set_orientation(&mut self, value: f32) {
                self.builder.set_data_field::<f32>(6, value);
            }
            #[inline]
            pub fn get_touch_major(self) -> f32 {
                self.builder.get_data_field::<f32>(7)
            }
            #[inline]
            pub fn set_touch_major(&mut self, value: f32) {
                self.builder.set_data_field::<f32>(7, value);
            }
            #[inline]
            pub fn get_touch_minor(self) -> f32 {
                self.builder.get_data_field::<f32>(8)
            }
            #[inline]
            pub fn set_touch_minor(&mut self, value: f32) {
                self.builder.set_data_field::<f32>(8, value);
            }
        }

        pub struct Pipeline {
            _typeless: ::capnp::any_pointer::Pipeline,
        }
        impl ::capnp::capability::FromTypelessPipeline for Pipeline {
            fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
                Self {
                    _typeless: typeless,
                }
            }
        }
        impl Pipeline {}
        mod _private {
            pub const TYPE_ID: u64 = 0xbb39_6f18_2e6e_a800;
        }
    }
}
